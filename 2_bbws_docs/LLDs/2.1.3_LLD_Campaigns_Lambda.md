# CPP Campaigns Lambda - Low-Level Design

**Version**: 3.0
**Created**: 2025-12-15
**Last Updated**: 2026-01-18
**Status**: Draft
**Component**: Campaigns Service (2_bbws_campaigns_lambda)
**Parent BRS**: [BRS 2.1.3: Campaign Management](../BRS/2.1.3_BRS_Campaign_Management.md)
**Parent HLD**: [HLD 2.1.3: Campaign Management](../HLDs/2.1.3_HLD_Campaign_Management.md)

---

## Document Control

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-12-15 | Agentic Architect | Initial version - GET campaign only |
| 2.0 | 2025-12-31 | Agentic Architect | **Complete CRUD**: Added full CRUD operations (list, get, create, update, delete). Renamed marketing to campaigns. Added REST API documentation, enhanced data models, sequence diagrams, and NFRs. |
| 3.0 | 2026-01-18 | Agentic Architect | **Update & Disable Promotions**: Enhanced update campaign with optimistic locking, modification history, and cache invalidation (BR-CMP-005 to BR-CMP-010). Added disable campaign with status transitions and grace period handling (BR-CMP-011 to BR-CMP-018). Added reactivate campaign endpoint. Added campaign history endpoint with pagination. Extended DynamoDB schema with version field and history records. Added new GSI for date-based queries. Added CloudFront cache invalidation. Updated status lifecycle to include SCHEDULED and DISABLED states. |

---

## 1. Introduction

### 1.1 Purpose

This LLD provides implementation-level details for the Campaigns Lambda service, which handles campaign management for the Customer Portal Public application. Campaigns are promotional offers with discounts, date ranges, and special conditions that can be applied to products.

### 1.2 Component Overview

| Attribute | Value |
|-----------|-------|
| Repository | `2_bbws_campaigns_lambda` |
| Runtime | Python 3.12 |
| Memory | 256MB |
| Timeout | 30s |
| Architecture | arm64 |

### 1.3 Lambda Functions

#### 1.3.1 Lambda Functions (9 Total - All API Handlers)

| Function | Endpoint | Trigger | Description |
|----------|----------|---------|-------------|
| list_campaigns | GET /v1.0/campaigns | API Gateway | List all active campaigns with pagination |
| get_campaign | GET /v1.0/campaigns/{code} | API Gateway | Get campaign by code with status validation |
| create_campaign | POST /v1.0/admin/campaigns | API Gateway | Validate request and create campaign in DynamoDB |
| update_campaign | PUT /v1.0/admin/campaigns/{code} | API Gateway | Update campaign with optimistic locking and history |
| disable_campaign | PATCH /v1.0/admin/campaigns/{code}/disable | API Gateway | Disable campaign with status validation |
| reactivate_campaign | PATCH /v1.0/admin/campaigns/{code}/reactivate | API Gateway | Reactivate disabled campaign with date validation |
| get_campaign_history | GET /v1.0/admin/campaigns/{code}/history | API Gateway | Get modification history with pagination |
| delete_campaign | DELETE /v1.0/admin/campaigns/{code} | API Gateway | Soft delete campaign in DynamoDB (set active=false) |
| admin_list_campaigns | GET /v1.0/admin/campaigns | API Gateway | List all campaigns (all statuses) for admin |

#### 1.3.2 Architecture Pattern

The Campaigns Service uses a **direct synchronous architecture** for all operations:
1. API Gateway receives campaign request (GET/POST/PUT/PATCH/DELETE)
2. API Lambda handler processes request and directly interacts with DynamoDB
3. For write operations, cache invalidation is triggered via CloudFront API
4. API returns appropriate response:
   - **201 Created** (POST - new campaign created)
   - **200 OK** (GET, PUT, PATCH - data retrieved/updated)
   - **204 No Content** (DELETE - campaign soft deleted)
   - **404 Not Found** (GET, PUT, PATCH, DELETE - campaign not found)
   - **409 Conflict** (PUT - version conflict during optimistic locking)

**All operations** are **synchronous** for immediate consistency.

**Benefits:**
- **Simplicity**: Direct DynamoDB integration, no message queues
- **Consistency**: Immediate consistency (read your writes)
- **Low Latency**: Single hop to database
- **Easy Testing**: Simple request-response flow
- **Reduced Cost**: No SQS charges
- **Single Deployable Unit**: All operations in monorepo (`2_bbws_campaigns_lambda/`)
- **Optimistic Locking**: Version-based conflict detection prevents concurrent update issues
- **Audit Trail**: All modifications automatically logged to history records
- **Cache Invalidation**: Automatic CloudFront cache invalidation for real-time updates

---

## 2. High Level Epic Overview

### 2.1 User Stories - API Operations

| User Story # | Epic | User Story | Test Scenario(s) |
|--------------|------|------------|------------------|
| US-CMP-001 | Campaigns | As a visitor, I want to view all campaigns | Given request, then all active campaigns returned with pagination |
| US-CMP-002 | Campaigns | As a visitor, I want to view campaign details | Given valid code, then campaign returned with status and discount |
| US-CMP-003 | Campaigns | As a visitor, I see if campaign is expired | Given expired campaign, then status=EXPIRED returned |
| US-CMP-004 | Campaigns | As a visitor, I see campaign discount | Given active campaign, then discount percentage and calculated prices shown |
| US-CMP-005 | Campaigns | As an admin, I want to create a new campaign | Given valid campaign data, then campaign created in DynamoDB and returns 201 Created with campaign details |
| US-CMP-006 | Campaigns | As an admin, I want to update a campaign | Given campaign code and update data, then campaign updated in DynamoDB and returns 200 OK with updated campaign |
| US-CMP-007 | Campaigns | As an admin, I want to delete a campaign | Given campaign code, then campaign soft deleted in DynamoDB (active=false) and returns 204 No Content |

### 2.2 User Stories - Update Promotions (Epic 3)

| User Story # | Epic | User Story | Test Scenario(s) |
|--------------|------|------------|------------------|
| US-CMP-011 | Update Promotions | As an admin, I want to update campaign name/description | Given existing campaign, when I update name/description, then changes reflected immediately and history recorded |
| US-CMP-012 | Update Promotions | As an admin, I want to modify discount percentage | Given active campaign, when I change discount, then new orders use updated discount; existing cart items retain original |
| US-CMP-013 | Update Promotions | As an admin, I want to extend/shorten campaign dates | Given active campaign, when I extend end date, then campaign continues; cannot shorten to past date |
| US-CMP-014 | Update Promotions | As an admin, I want to change applicable products | Given active campaign, when I update productId, then pricing display updates accordingly |
| US-CMP-015 | Update Promotions | As an admin, I want to update terms and conditions | Given any campaign, when I update terms, then customers see updated terms |
| US-CMP-016 | Update Promotions | As an admin, I want to see history of changes | Given any campaign, when I request history, then audit records with timestamp, user, and values returned |
| US-CMP-017 | Update Promotions | As a system, I want to prevent concurrent conflicts | Given concurrent updates, when version mismatch detected, then return 409 Conflict |

### 2.3 User Stories - Disable Promotions (Epic 4)

| User Story # | Epic | User Story | Test Scenario(s) |
|--------------|------|------------|------------------|
| US-CMP-018 | Disable Promotions | As an admin, I want to disable an active campaign | Given active campaign, when I disable it, then customers no longer see it; new orders cannot use discount |
| US-CMP-019 | Disable Promotions | As an admin, I want to disable a scheduled campaign | Given scheduled campaign, when I disable it, then it does not activate on start date |
| US-CMP-020 | Disable Promotions | As an admin, I want to see disabled campaigns | Given admin campaign list, when I filter by status, then disabled campaigns shown separately |
| US-CMP-021 | Disable Promotions | As an admin, I want to reactivate a disabled campaign | Given disabled campaign with valid future end date, when I reactivate, then campaign becomes active/scheduled |
| US-CMP-022 | Disable Promotions | As an admin, I want to add disable reason | Given disable action, when I provide reason, then it is stored with status change |
| US-CMP-023 | Disable Promotions | As a customer, I should not see disabled campaigns | Given disabled campaign, when I visit promotions page, then disabled campaign not displayed |
| US-CMP-024 | Disable Promotions | As a system, I want to honour cart discounts during grace period | Given disabled campaign with items in cart, when within 24 hours, then discount honoured at checkout |

### 2.4 User Stories - Data Operations

| User Story # | Epic | User Story | Test Scenario(s) |
|--------------|------|------------|------------------|
| US-CMP-025 | Campaign Processing | As a system, I want to persist campaign data | Given valid campaign data, then campaign saved to DynamoDB with all fields and returns 201 Created |
| US-CMP-026 | Campaign Processing | As a system, I want to handle validation errors | Given invalid campaign data, then return 400 Bad Request with validation errors |
| US-CMP-027 | Campaign Processing | As a system, I want to handle database errors | Given DynamoDB failure, then return 500 Internal Server Error and log error |
| US-CMP-028 | Campaign Processing | As a system, I want to record modification history | Given any update/disable/reactivate, then history record created with all change details |
| US-CMP-029 | Campaign Processing | As a system, I want to invalidate cache on changes | Given campaign update/disable/reactivate, then CloudFront cache invalidated within 2 seconds |

---

## 3. Component Diagram

```mermaid
classDiagram
    %% API Handlers
    class CampaignAPIHandler {
        -CampaignService campaignService
        -HistoryService historyService
        -CacheService cacheService
        -RequestValidator validator
        -ResponseBuilder responseBuilder
        +handleList(event dict, context LambdaContext) dict
        +handleAdminList(event dict, context LambdaContext) dict
        +handleGet(event dict, context LambdaContext) dict
        +handleCreate(event dict, context LambdaContext) dict
        +handleUpdate(event dict, context LambdaContext) dict
        +handleDisable(event dict, context LambdaContext) dict
        +handleReactivate(event dict, context LambdaContext) dict
        +handleGetHistory(event dict, context LambdaContext) dict
        +handleDelete(event dict, context LambdaContext) dict
        -extractPathParams(event dict) dict
        -extractUserFromJwt(event dict) str
    }

    %% Services
    class CampaignService {
        -CampaignRepository repository
        -HistoryService historyService
        -CacheService cacheService
        +listCampaigns(pagination dict, includeDisabled bool) List~Campaign~
        +getCampaign(code str) Campaign
        +createCampaign(data dict, createdBy str) Campaign
        +updateCampaign(code str, data dict, updatedBy str, version int) Campaign
        +disableCampaign(code str, reason str, disabledBy str) Campaign
        +reactivateCampaign(code str, newEndDate str, reactivatedBy str) Campaign
        +deleteCampaign(code str) bool
        -validateCampaignStatus(campaign Campaign) Campaign
        -calculateEffectivePrice(campaign Campaign) Campaign
        -calculateStatus(campaign Campaign) CampaignStatus
        -validateStatusTransition(fromStatus CampaignStatus, toStatus CampaignStatus) bool
        -validateBusinessRules(campaign Campaign, updateData dict) List~str~
    }

    class HistoryService {
        -CampaignRepository repository
        +recordModification(code str, changeType str, field str, oldValue str, newValue str, modifiedBy str) ModificationHistory
        +recordBulkModification(code str, changeType str, changes List~dict~, modifiedBy str) List~ModificationHistory~
        +getHistory(code str, pagination dict) HistoryResponse
        -createHistoryRecord(code str, changeType str, field str, oldValue str, newValue str, modifiedBy str) ModificationHistory
    }

    class CacheService {
        -CloudFrontClient cloudFrontClient
        -str distributionId
        +invalidateCampaignCache(code str) bool
        +invalidateAllCampaignsCache() bool
        -createInvalidation(paths List~str~) str
    }

    class CampaignRepository {
        -Table table
        +findAll(pagination dict, statusFilter str) List~Campaign~
        +findByCode(code str) Optional~Campaign~
        +create(campaign Campaign) Campaign
        +updateWithVersionCheck(code str, updateData dict, expectedVersion int) Campaign
        +updateStatus(code str, status str, metadata dict) Campaign
        +softDelete(code str) bool
        +saveHistoryRecord(history ModificationHistory) ModificationHistory
        +queryHistory(code str, pagination dict) List~ModificationHistory~
        -toEntity(item dict) Campaign
        -toHistoryEntity(item dict) ModificationHistory
    }

    class Campaign {
        +str code
        +str name
        +str description
        +str productId
        +int discountPercent
        +Decimal listPrice
        +Decimal price
        +str termsAndConditions
        +CampaignStatus status
        +str fromDate
        +str toDate
        +str specialConditions
        +str createdAt
        +str createdBy
        +str updatedAt
        +str updatedBy
        +str disabledAt
        +str disabledBy
        +str disableReason
        +str reactivatedAt
        +str reactivatedBy
        +int version
        +bool active
    }

    class ModificationHistory {
        +str modificationId
        +str campaignCode
        +str modifiedBy
        +str modifiedAt
        +str fieldChanged
        +str previousValue
        +str newValue
        +str changeType
        +str ipAddress
        +str userAgent
    }

    class CampaignStatus {
        <<enumeration>>
        DRAFT
        SCHEDULED
        ACTIVE
        DISABLED
        EXPIRED
    }

    class ChangeType {
        <<enumeration>>
        UPDATE
        DISABLE
        REACTIVATE
        CREATE
        DELETE
    }

    class CampaignNotFoundException {
        +str message
        +str code
        +int statusCode
    }

    class ValidationException {
        +str message
        +List~str~ errors
        +int statusCode
    }

    class VersionConflictException {
        +str message
        +int currentVersion
        +int expectedVersion
        +int statusCode
    }

    class InvalidStatusTransitionException {
        +str message
        +str currentStatus
        +str targetStatus
        +int statusCode
    }

    %% API Handler Relationships
    CampaignAPIHandler --> CampaignService : all CRUD operations
    CampaignAPIHandler --> HistoryService : history queries
    CampaignService --> CampaignRepository
    CampaignService --> HistoryService
    CampaignService --> CacheService
    HistoryService --> CampaignRepository
    CampaignRepository --> Campaign
    CampaignRepository --> ModificationHistory
    Campaign --> CampaignStatus
    ModificationHistory --> ChangeType
```

---

## 4. Sequence Diagrams

### 4.1 List Campaigns Flow

```mermaid
sequenceDiagram
    participant Client
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant CampaignRepository
    participant DynamoDB

    Client->>APIGateway: GET /v1.0/campaigns
    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignService: listCampaigns()

        CampaignService->>CampaignRepository: findAll()
        CampaignRepository->>DynamoDB: scan(FilterExpression=active=true)
        DynamoDB-->>CampaignRepository: items[]
        CampaignRepository-->>CampaignService: List~Campaign~

        CampaignService->>CampaignService: filterActiveCampaigns(campaigns)
        CampaignService->>CampaignService: validateCampaignStatuses(campaigns)
        CampaignService-->>CampaignHandler: List~Campaign~

        CampaignHandler-->>APIGateway: {statusCode: 200, body: campaigns}
        APIGateway-->>Client: 200 OK
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Client: 500 Internal Server Error
    end
```

### 4.2 Get Campaign Flow

```mermaid
sequenceDiagram
    participant Client
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant CampaignRepository
    participant DynamoDB

    Client->>APIGateway: GET /v1.0/campaigns/{code}
    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: extractPathParams(event)
        CampaignHandler->>CampaignService: getCampaign(code)

        CampaignService->>CampaignRepository: findByCode(code)
        CampaignRepository->>DynamoDB: get_item(PK=CAMPAIGN#{code})
        DynamoDB-->>CampaignRepository: item
        CampaignRepository-->>CampaignService: Optional~Campaign~

        alt Campaign not found
            CampaignService-->>CampaignHandler: throw CampaignNotFoundException
        end

        CampaignService->>CampaignService: validateCampaignStatus(campaign)
        Note over CampaignService: Check dates, update status if expired

        CampaignService->>CampaignService: calculateEffectivePrice(campaign)
        CampaignService-->>CampaignHandler: Campaign

        CampaignHandler-->>APIGateway: {statusCode: 200, body: campaign}
        APIGateway-->>Client: 200 OK
    end

    alt BusinessException (Expected Errors)
        Note over CampaignService: catch BusinessException
        CampaignHandler-->>APIGateway: {statusCode: 404, body: "Campaign not found"}
        APIGateway-->>Client: 404 Not Found
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Client: 500 Internal Server Error
    end
```

### 4.3 Create Campaign Flow

```mermaid
sequenceDiagram
    participant Client
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant CampaignRepository
    participant DynamoDB

    Client->>APIGateway: POST /v1.0/campaigns
    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: Parse and validate request body
        CampaignHandler->>CampaignService: createCampaign(campaignData)

        CampaignService->>CampaignService: Validate campaign data
        CampaignService->>CampaignService: Calculate effective price
        CampaignService->>CampaignService: Determine initial status from dates

        CampaignService->>CampaignRepository: findByCode(code)
        CampaignRepository->>DynamoDB: get_item(PK=CAMPAIGN#{code})
        DynamoDB-->>CampaignRepository: null (not exists)

        alt Campaign code already exists
            CampaignService-->>CampaignHandler: throw ValidationException("Campaign code already exists")
        end

        CampaignService->>CampaignRepository: create(campaign)
        CampaignRepository->>DynamoDB: put_item(campaign)
        DynamoDB-->>CampaignRepository: success
        CampaignRepository-->>CampaignService: Campaign

        CampaignService-->>CampaignHandler: Campaign
        CampaignHandler-->>APIGateway: {statusCode: 201, body: campaign}
        APIGateway-->>Client: 201 Created
    end

    alt ValidationException (Invalid Input)
        Note over CampaignHandler: catch ValidationException
        CampaignHandler->>CampaignHandler: logger.warning(validation_error)
        CampaignHandler-->>APIGateway: {statusCode: 400, body: "Invalid campaign data"}
        APIGateway-->>Client: 400 Bad Request
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Client: 500 Internal Server Error
    end
```

### 4.4 Update Campaign Flow (Enhanced with Optimistic Locking)

```mermaid
sequenceDiagram
    participant Admin
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant HistoryService
    participant CacheService
    participant CampaignRepository
    participant DynamoDB
    participant CloudFront

    Admin->>APIGateway: PUT /v1.0/admin/campaigns/{code}
    Note over Admin,APIGateway: JWT token + version field in body

    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: extractUserFromJwt(event)
        CampaignHandler->>CampaignHandler: Validate JWT + Admin role
        CampaignHandler->>CampaignHandler: Extract code from path
        CampaignHandler->>CampaignHandler: Validate request body
        CampaignHandler->>CampaignService: updateCampaign(code, updateData, user, version)

        CampaignService->>CampaignRepository: findByCode(code)
        CampaignRepository->>DynamoDB: get_item(PK=CAMPAIGN#{code}, SK=METADATA)
        DynamoDB-->>CampaignRepository: item
        CampaignRepository-->>CampaignService: Optional~Campaign~

        alt Campaign not found
            CampaignService-->>CampaignHandler: throw CampaignNotFoundException
        end

        CampaignService->>CampaignService: Check version match
        alt Version mismatch
            CampaignService-->>CampaignHandler: throw VersionConflictException
        end

        CampaignService->>CampaignService: validateBusinessRules(campaign, updateData)
        Note over CampaignService: BR-CMP-008: No past end date for active<br/>BR-CMP-009: Code immutable<br/>BR-CMP-010: Expired not auto-reactivated

        CampaignService->>CampaignService: Calculate changed fields
        CampaignService->>CampaignService: Recalculate effective price if needed
        CampaignService->>CampaignService: Recalculate status from dates

        CampaignService->>CampaignRepository: TransactWriteItems
        Note over CampaignRepository,DynamoDB: 1. Update campaign (version++)<br/>2. Insert history record(s)
        CampaignRepository->>DynamoDB: transact_write_items(Update + Put)
        DynamoDB-->>CampaignRepository: success
        CampaignRepository-->>CampaignService: Campaign

        CampaignService->>HistoryService: recordBulkModification(code, UPDATE, changes, user)
        Note over HistoryService: History already saved in transaction

        CampaignService->>CacheService: invalidateCampaignCache(code)
        CacheService->>CloudFront: CreateInvalidation(/v1.0/campaigns/*)
        CloudFront-->>CacheService: invalidation queued
        CacheService-->>CampaignService: success

        CampaignService-->>CampaignHandler: Campaign
        CampaignHandler-->>APIGateway: {statusCode: 200, body: campaign, _links}
        APIGateway-->>Admin: 200 OK with HATEOAS links
    end

    alt VersionConflictException
        Note over CampaignService: Optimistic lock failure
        CampaignHandler-->>APIGateway: {statusCode: 409, body: "Version conflict"}
        APIGateway-->>Admin: 409 Conflict
    end

    alt ValidationException (Business Rule Violation)
        Note over CampaignHandler: catch ValidationException
        CampaignHandler-->>APIGateway: {statusCode: 400, body: errors}
        APIGateway-->>Admin: 400 Bad Request
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Admin: 500 Internal Server Error
    end
```

### 4.5 Disable Campaign Flow

```mermaid
sequenceDiagram
    participant Admin
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant HistoryService
    participant CacheService
    participant CampaignRepository
    participant DynamoDB
    participant CloudFront
    participant CartService

    Admin->>APIGateway: PATCH /v1.0/admin/campaigns/{code}/disable
    Note over Admin,APIGateway: JWT token + optional reason

    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: extractUserFromJwt(event)
        CampaignHandler->>CampaignHandler: Validate JWT + Admin role
        CampaignHandler->>CampaignHandler: Extract code from path
        CampaignHandler->>CampaignService: disableCampaign(code, reason, user)

        CampaignService->>CampaignRepository: findByCode(code)
        CampaignRepository->>DynamoDB: get_item(PK=CAMPAIGN#{code}, SK=METADATA)
        DynamoDB-->>CampaignRepository: item
        CampaignRepository-->>CampaignService: Optional~Campaign~

        alt Campaign not found
            CampaignService-->>CampaignHandler: throw CampaignNotFoundException
        end

        CampaignService->>CampaignService: validateStatusTransition(current, DISABLED)
        Note over CampaignService: BR-CMP-013: Only ACTIVE,<br/>SCHEDULED, EXPIRED can be disabled

        alt Invalid status transition
            CampaignService-->>CampaignHandler: throw InvalidStatusTransitionException
        end

        CampaignService->>CampaignRepository: TransactWriteItems
        Note over CampaignRepository,DynamoDB: 1. Update status=DISABLED<br/>2. Set disabledAt, disabledBy, disableReason<br/>3. Increment version<br/>4. Insert history record
        CampaignRepository->>DynamoDB: transact_write_items(Update + Put)
        DynamoDB-->>CampaignRepository: success
        CampaignRepository-->>CampaignService: Campaign

        CampaignService->>CacheService: invalidateCampaignCache(code)
        CacheService->>CloudFront: CreateInvalidation(/v1.0/campaigns/*)
        CloudFront-->>CacheService: invalidation queued

        CampaignService->>CartService: notifyDisabledCampaign(code, gracePeriodEnd)
        Note over CartService: BR-CMP-015: Cart honours<br/>discount for 24 hours
        CartService-->>CampaignService: acknowledged

        CampaignService-->>CampaignHandler: Campaign
        CampaignHandler-->>APIGateway: {statusCode: 200, body: campaign, _links}
        Note over CampaignHandler,APIGateway: _links includes reactivate link
        APIGateway-->>Admin: 200 OK
    end

    alt InvalidStatusTransitionException
        Note over CampaignService: Invalid status for disable
        CampaignHandler-->>APIGateway: {statusCode: 400, body: "Cannot disable campaign in current status"}
        APIGateway-->>Admin: 400 Bad Request
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Admin: 500 Internal Server Error
    end
```

### 4.6 Reactivate Campaign Flow

```mermaid
sequenceDiagram
    participant Admin
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant HistoryService
    participant CacheService
    participant CampaignRepository
    participant DynamoDB
    participant CloudFront

    Admin->>APIGateway: PATCH /v1.0/admin/campaigns/{code}/reactivate
    Note over Admin,APIGateway: JWT token + optional new toDate

    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: extractUserFromJwt(event)
        CampaignHandler->>CampaignHandler: Validate JWT + Admin role
        CampaignHandler->>CampaignHandler: Extract code from path
        CampaignHandler->>CampaignService: reactivateCampaign(code, newEndDate, user)

        CampaignService->>CampaignRepository: findByCode(code)
        CampaignRepository->>DynamoDB: get_item(PK=CAMPAIGN#{code}, SK=METADATA)
        DynamoDB-->>CampaignRepository: item
        CampaignRepository-->>CampaignService: Optional~Campaign~

        alt Campaign not found
            CampaignService-->>CampaignHandler: throw CampaignNotFoundException
        end

        CampaignService->>CampaignService: Validate current status = DISABLED
        alt Not disabled
            CampaignService-->>CampaignHandler: throw InvalidStatusTransitionException
        end

        CampaignService->>CampaignService: Validate end date is in future
        Note over CampaignService: BR-CMP-014: toDate must be in future

        alt End date in past
            CampaignService-->>CampaignHandler: throw ValidationException("End date must be future")
        end

        CampaignService->>CampaignService: calculateStatus(campaign)
        Note over CampaignService: If fromDate > now: SCHEDULED<br/>If fromDate <= now <= toDate: ACTIVE

        CampaignService->>CampaignRepository: TransactWriteItems
        Note over CampaignRepository,DynamoDB: 1. Update status (SCHEDULED/ACTIVE)<br/>2. Set reactivatedAt, reactivatedBy<br/>3. Update toDate if provided<br/>4. Clear disabled fields<br/>5. Increment version<br/>6. Insert history record
        CampaignRepository->>DynamoDB: transact_write_items(Update + Put)
        DynamoDB-->>CampaignRepository: success
        CampaignRepository-->>CampaignService: Campaign

        CampaignService->>CacheService: invalidateCampaignCache(code)
        CacheService->>CloudFront: CreateInvalidation(/v1.0/campaigns/*)
        CloudFront-->>CacheService: invalidation queued

        CampaignService-->>CampaignHandler: Campaign
        CampaignHandler-->>APIGateway: {statusCode: 200, body: campaign, _links}
        Note over CampaignHandler,APIGateway: _links includes disable link
        APIGateway-->>Admin: 200 OK
    end

    alt InvalidStatusTransitionException
        Note over CampaignService: Campaign not in DISABLED status
        CampaignHandler-->>APIGateway: {statusCode: 400, body: "Campaign is not disabled"}
        APIGateway-->>Admin: 400 Bad Request
    end

    alt ValidationException (Invalid End Date)
        Note over CampaignHandler: End date validation failed
        CampaignHandler-->>APIGateway: {statusCode: 400, body: "End date must be in future"}
        APIGateway-->>Admin: 400 Bad Request
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Admin: 500 Internal Server Error
    end
```

### 4.7 Get Campaign History Flow

```mermaid
sequenceDiagram
    participant Admin
    participant APIGateway
    participant CampaignHandler
    participant HistoryService
    participant CampaignRepository
    participant DynamoDB

    Admin->>APIGateway: GET /v1.0/admin/campaigns/{code}/history
    Note over Admin,APIGateway: JWT token + optional pagination params

    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: extractUserFromJwt(event)
        CampaignHandler->>CampaignHandler: Validate JWT + Admin role
        CampaignHandler->>CampaignHandler: Extract code from path
        CampaignHandler->>CampaignHandler: Extract pagination params (limit, startKey)

        CampaignHandler->>HistoryService: getHistory(code, pagination)

        HistoryService->>CampaignRepository: queryHistory(code, pagination)
        CampaignRepository->>DynamoDB: Query(PK=CAMPAIGN#{code}, SK begins_with HISTORY#)
        Note over CampaignRepository,DynamoDB: Sorted by timestamp descending<br/>ScanIndexForward=false

        DynamoDB-->>CampaignRepository: items[], LastEvaluatedKey
        CampaignRepository-->>HistoryService: List~ModificationHistory~, nextKey

        HistoryService->>HistoryService: Format history response
        Note over HistoryService: Include changeType, field,<br/>previous/new values, user, timestamp

        HistoryService-->>CampaignHandler: HistoryResponse

        CampaignHandler-->>APIGateway: {statusCode: 200, body: history, _links}
        Note over CampaignHandler,APIGateway: _links includes campaign, next page
        APIGateway-->>Admin: 200 OK with paginated history
    end

    alt CampaignNotFoundException
        Note over HistoryService: No campaign with this code
        CampaignHandler-->>APIGateway: {statusCode: 404, body: "Campaign not found"}
        APIGateway-->>Admin: 404 Not Found
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Admin: 500 Internal Server Error
    end
```

### 4.8 Delete Campaign Flow (Soft Delete)

```mermaid
sequenceDiagram
    participant Client
    participant APIGateway
    participant CampaignHandler
    participant CampaignService
    participant CampaignRepository
    participant DynamoDB

    Client->>APIGateway: DELETE /v1.0/campaigns/{code}
    APIGateway->>CampaignHandler: handle(event, context)

    rect rgb(240, 240, 255)
        Note over CampaignHandler: try block - Main Logic

        CampaignHandler->>CampaignHandler: Extract code from path
        CampaignHandler->>CampaignService: deleteCampaign(code)

        CampaignService->>CampaignRepository: findByCode(code)
        CampaignRepository->>DynamoDB: get_item(PK=CAMPAIGN#{code})
        DynamoDB-->>CampaignRepository: item
        CampaignRepository-->>CampaignService: Optional~Campaign~

        alt Campaign exists
            CampaignService->>CampaignRepository: softDelete(code)
            Note over CampaignRepository: Set active=false
            CampaignRepository->>DynamoDB: update_item(PK=CAMPAIGN#{code}, SET active=false)
            DynamoDB-->>CampaignRepository: success
            CampaignRepository-->>CampaignService: true

            CampaignService-->>CampaignHandler: true
            CampaignHandler-->>APIGateway: {statusCode: 204, body: empty}
            APIGateway-->>Client: 204 No Content
        else Campaign not found
            CampaignService-->>CampaignHandler: false
            CampaignHandler-->>APIGateway: {statusCode: 404, body: "Campaign not found"}
            APIGateway-->>Client: 404 Not Found
        end
    end

    alt UnexpectedException (System Errors)
        Note over CampaignHandler: catch UnexpectedException
        CampaignHandler->>CampaignHandler: logger.error(exception)
        CampaignHandler-->>APIGateway: {statusCode: 500, body: "Internal server error"}
        APIGateway-->>Client: 500 Internal Server Error
    end
```

---

## 5. Data Models

### 5.1 DynamoDB Schema

#### 5.1.1 Single Table Design

**Table Name**: `campaigns`

**Capacity Mode**: On-Demand

#### 5.1.2 Access Patterns

| # | Access Pattern | Solution |
|---|----------------|----------|
| AP1 | List all active campaigns (public) | GSI1 query: GSI1_PK=`CAMPAIGN`, filter status NOT IN (DISABLED, DRAFT) |
| AP2 | Get campaign by code | Base table query: PK=`CAMPAIGN#{code}` AND SK=`METADATA` |
| AP3 | List campaigns by status (admin) | GSI1 query: GSI1_PK=`CAMPAIGN`, filter by status |
| AP4 | List campaigns by end date | GSI2 query: GSI2_PK=`CAMPAIGN`, GSI2_SK begins_with `{toDate}` |
| AP5 | Get campaign modification history | Base table query: PK=`CAMPAIGN#{code}`, SK begins_with `HISTORY#` |
| AP6 | List all campaigns (admin, all statuses) | GSI1 query: GSI1_PK=`CAMPAIGN` (no filter) |

#### 5.1.3 Primary Key Structure

| Key | Attribute | Pattern | Example |
|-----|-----------|---------|---------|
| PK (Partition Key) | `PK` | `CAMPAIGN#{code}` | `CAMPAIGN#SUMMER2026` |
| SK (Sort Key) | `SK` | `METADATA` or `HISTORY#{timestamp}#{uuid}` | `METADATA` or `HISTORY#2026-01-18T14:30:00Z#uuid-123` |

#### 5.1.4 Campaign Entity Attributes (Main Record)

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| PK | String | Yes | `CAMPAIGN#{code}` - Partition key |
| SK | String | Yes | `METADATA` - Sort key for campaign record |
| entityType | String | Yes | `CAMPAIGN` - Entity type discriminator |
| code | String | Yes | Unique campaign code (e.g., SUMMER2026) - **immutable after creation** |
| name | String | Yes | Campaign display name |
| description | String | No | Campaign description (max 500 chars) |
| productId | String | Yes | Associated product ID |
| discountPercent | Number | Yes | Discount percentage (0-100) |
| listPrice | Number | Yes | Original price before discount |
| price | Number | Yes | Calculated discounted price |
| termsAndConditions | String | Yes | Campaign terms and conditions (max 2000 chars) |
| status | String | Yes | DRAFT, SCHEDULED, ACTIVE, DISABLED, EXPIRED |
| fromDate | String | Yes | Start date (ISO 8601) |
| toDate | String | Yes | End date (ISO 8601) |
| specialConditions | String | No | Additional conditions (max 500 chars) |
| createdAt | String | Yes | ISO 8601 timestamp |
| createdBy | String | Yes | User who created the campaign |
| updatedAt | String | Yes | ISO 8601 timestamp |
| updatedBy | String | Yes | User who last updated |
| disabledAt | String | No | Timestamp when disabled (nullable) |
| disabledBy | String | No | User who disabled (nullable) |
| disableReason | String | No | Reason for disabling (nullable, max 500 chars) |
| reactivatedAt | String | No | Timestamp when reactivated (nullable) |
| reactivatedBy | String | No | User who reactivated (nullable) |
| version | Number | Yes | Optimistic locking version (starts at 1, incremented on each update) |
| active | Boolean | Yes | Soft delete flag (true = active, false = deleted) |
| GSI1_PK | String | Yes | `CAMPAIGN` (for GSI1) |
| GSI1_SK | String | Yes | `{status}#{code}` (for GSI1 filtering by status) |
| GSI2_PK | String | Yes | `CAMPAIGN` (for GSI2) |
| GSI2_SK | String | Yes | `{toDate}#{code}` (for GSI2 querying by end date) |

#### 5.1.5 Modification History Entity Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| PK | String | Yes | `CAMPAIGN#{code}` - Same partition as campaign |
| SK | String | Yes | `HISTORY#{timestamp}#{uuid}` - Sort key for chronological ordering |
| entityType | String | Yes | `HISTORY` - Entity type discriminator |
| modificationId | String | Yes | Unique identifier for change record (UUID) |
| campaignCode | String | Yes | Reference to modified campaign |
| modifiedBy | String | Yes | User who made the change (from JWT) |
| modifiedAt | String | Yes | Timestamp of modification (ISO 8601) |
| fieldChanged | String | Yes | Name of field that was modified |
| previousValue | String | Yes | Value before change (JSON encoded for complex types) |
| newValue | String | Yes | Value after change (JSON encoded for complex types) |
| changeType | String | Yes | UPDATE, DISABLE, REACTIVATE, CREATE, DELETE |
| ipAddress | String | No | Client IP (from X-Forwarded-For header) |
| userAgent | String | No | Client user agent |

#### 5.1.6 Global Secondary Indexes

**GSI1: CampaignsByStatusIndex**

Enables querying campaigns by status for both public (filter ACTIVE only) and admin (all statuses) views.

| Attribute | Type | Key Type | Description |
|-----------|------|----------|-------------|
| GSI1_PK | String | Partition Key | `CAMPAIGN` (constant for all campaigns) |
| GSI1_SK | String | Sort Key | `{status}#{code}` (sortable by status then code) |

**Projection**: ALL

**Use Cases**:
- `GET /v1.0/campaigns` (public - filter for ACTIVE only)
- `GET /v1.0/admin/campaigns?status=DISABLED` (admin - specific status)
- `GET /v1.0/admin/campaigns` (admin - all statuses)

**GSI2: CampaignsByDateIndex**

Enables querying campaigns by end date for expiration processing and date-based queries.

| Attribute | Type | Key Type | Description |
|-----------|------|----------|-------------|
| GSI2_PK | String | Partition Key | `CAMPAIGN` (constant for all campaigns) |
| GSI2_SK | String | Sort Key | `{toDate}#{code}` (sortable by end date) |

**Projection**: ALL

**Use Cases**:
- Find campaigns expiring within a date range
- Batch status update for expired campaigns
- Campaign lifecycle management

#### 5.1.7 Example DynamoDB Items

**Campaign Record (Main Entity)**:

```json
{
  "PK": "CAMPAIGN#SUMMER2026",
  "SK": "METADATA",
  "entityType": "CAMPAIGN",
  "code": "SUMMER2026",
  "name": "Summer Sale 2026",
  "description": "Get 25% off all hosting packages this summer!",
  "productId": "PROD-002",
  "discountPercent": 25,
  "listPrice": 1500.00,
  "price": 1125.00,
  "termsAndConditions": "Valid for new customers only. Cannot be combined with other offers.",
  "status": "ACTIVE",
  "fromDate": "2026-06-01T00:00:00Z",
  "toDate": "2026-08-31T23:59:59Z",
  "specialConditions": "Minimum purchase of R500 required",
  "createdAt": "2026-05-15T10:00:00Z",
  "createdBy": "admin@kimmyai.io",
  "updatedAt": "2026-06-20T14:30:00Z",
  "updatedBy": "marketing@kimmyai.io",
  "disabledAt": null,
  "disabledBy": null,
  "disableReason": null,
  "reactivatedAt": null,
  "reactivatedBy": null,
  "version": 3,
  "active": true,
  "GSI1_PK": "CAMPAIGN",
  "GSI1_SK": "ACTIVE#SUMMER2026",
  "GSI2_PK": "CAMPAIGN",
  "GSI2_SK": "2026-08-31T23:59:59Z#SUMMER2026"
}
```

**Modification History Record**:

```json
{
  "PK": "CAMPAIGN#SUMMER2026",
  "SK": "HISTORY#2026-06-20T14:30:00Z#550e8400-e29b-41d4-a716-446655440000",
  "entityType": "HISTORY",
  "modificationId": "550e8400-e29b-41d4-a716-446655440000",
  "campaignCode": "SUMMER2026",
  "modifiedBy": "marketing@kimmyai.io",
  "modifiedAt": "2026-06-20T14:30:00Z",
  "fieldChanged": "discountPercent",
  "previousValue": "20",
  "newValue": "25",
  "changeType": "UPDATE",
  "ipAddress": "41.132.45.67",
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"
}
```

**Disabled Campaign Record**:

```json
{
  "PK": "CAMPAIGN#WINTER2026",
  "SK": "METADATA",
  "entityType": "CAMPAIGN",
  "code": "WINTER2026",
  "name": "Winter Special 2026",
  "description": "Winter promotion - paused for review",
  "productId": "PROD-001",
  "discountPercent": 15,
  "listPrice": 1000.00,
  "price": 850.00,
  "termsAndConditions": "Limited time offer.",
  "status": "DISABLED",
  "fromDate": "2026-07-01T00:00:00Z",
  "toDate": "2026-08-31T23:59:59Z",
  "specialConditions": null,
  "createdAt": "2026-06-01T10:00:00Z",
  "createdBy": "admin@kimmyai.io",
  "updatedAt": "2026-07-15T09:00:00Z",
  "updatedBy": "admin@kimmyai.io",
  "disabledAt": "2026-07-15T09:00:00Z",
  "disabledBy": "admin@kimmyai.io",
  "disableReason": "Campaign underperforming - pausing for review",
  "reactivatedAt": null,
  "reactivatedBy": null,
  "version": 5,
  "active": true,
  "GSI1_PK": "CAMPAIGN",
  "GSI1_SK": "DISABLED#WINTER2026",
  "GSI2_PK": "CAMPAIGN",
  "GSI2_SK": "2026-08-31T23:59:59Z#WINTER2026"
}
```

**Disable History Record**:

```json
{
  "PK": "CAMPAIGN#WINTER2026",
  "SK": "HISTORY#2026-07-15T09:00:00Z#660e8400-e29b-41d4-a716-446655440001",
  "entityType": "HISTORY",
  "modificationId": "660e8400-e29b-41d4-a716-446655440001",
  "campaignCode": "WINTER2026",
  "modifiedBy": "admin@kimmyai.io",
  "modifiedAt": "2026-07-15T09:00:00Z",
  "fieldChanged": "status",
  "previousValue": "ACTIVE",
  "newValue": "DISABLED",
  "changeType": "DISABLE",
  "ipAddress": "41.132.45.67",
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"
}
```

### 5.2 Pydantic Models

```python
from pydantic import BaseModel, Field, field_validator, model_validator
from decimal import Decimal
from enum import Enum
from typing import Optional, List, Dict, Any
from datetime import datetime
import uuid

# =============================================================================
# ENUMERATIONS
# =============================================================================

class CampaignStatus(str, Enum):
    """Campaign status lifecycle states"""
    DRAFT = "DRAFT"           # Initial creation state
    SCHEDULED = "SCHEDULED"   # fromDate > current date
    ACTIVE = "ACTIVE"         # fromDate <= current date <= toDate
    DISABLED = "DISABLED"     # Manually deactivated by admin
    EXPIRED = "EXPIRED"       # toDate < current date

class ChangeType(str, Enum):
    """Types of modifications that can be made to campaigns"""
    CREATE = "CREATE"
    UPDATE = "UPDATE"
    DISABLE = "DISABLE"
    REACTIVATE = "REACTIVATE"
    DELETE = "DELETE"

# =============================================================================
# CORE ENTITY MODELS
# =============================================================================

class Campaign(BaseModel):
    """Campaign entity with full lifecycle support"""
    code: str
    name: str
    description: Optional[str] = Field(None, max_length=500)
    product_id: str = Field(..., alias="productId")
    discount_percent: int = Field(..., alias="discountPercent", ge=0, le=100)
    list_price: Decimal = Field(..., alias="listPrice", gt=0)
    price: Decimal = Field(..., gt=0)
    terms_and_conditions: str = Field(..., alias="termsAndConditions", max_length=2000)
    status: CampaignStatus
    from_date: str = Field(..., alias="fromDate")
    to_date: str = Field(..., alias="toDate")
    special_conditions: Optional[str] = Field(None, alias="specialConditions", max_length=500)
    created_at: datetime = Field(..., alias="createdAt")
    created_by: str = Field(..., alias="createdBy")
    updated_at: datetime = Field(..., alias="updatedAt")
    updated_by: str = Field(..., alias="updatedBy")
    disabled_at: Optional[datetime] = Field(None, alias="disabledAt")
    disabled_by: Optional[str] = Field(None, alias="disabledBy")
    disable_reason: Optional[str] = Field(None, alias="disableReason", max_length=500)
    reactivated_at: Optional[datetime] = Field(None, alias="reactivatedAt")
    reactivated_by: Optional[str] = Field(None, alias="reactivatedBy")
    version: int = Field(default=1, ge=1)
    active: bool = True

    class Config:
        populate_by_name = True

class ModificationHistory(BaseModel):
    """Modification history record for audit trail"""
    modification_id: str = Field(default_factory=lambda: str(uuid.uuid4()), alias="modificationId")
    campaign_code: str = Field(..., alias="campaignCode")
    modified_by: str = Field(..., alias="modifiedBy")
    modified_at: datetime = Field(..., alias="modifiedAt")
    field_changed: str = Field(..., alias="fieldChanged")
    previous_value: str = Field(..., alias="previousValue")
    new_value: str = Field(..., alias="newValue")
    change_type: ChangeType = Field(..., alias="changeType")
    ip_address: Optional[str] = Field(None, alias="ipAddress")
    user_agent: Optional[str] = Field(None, alias="userAgent")

    class Config:
        populate_by_name = True

# =============================================================================
# RESPONSE MODELS
# =============================================================================

class HATEOASLinks(BaseModel):
    """HATEOAS links for campaign responses"""
    self_link: str = Field(..., alias="self")
    history: Optional[str] = None
    disable: Optional[str] = None
    reactivate: Optional[str] = None

    class Config:
        populate_by_name = True

class CampaignResponse(BaseModel):
    """Campaign response with validity flag and HATEOAS links"""
    code: str
    name: str
    description: Optional[str] = None
    product_id: str = Field(..., alias="productId")
    discount_percent: int = Field(..., alias="discountPercent")
    list_price: Decimal = Field(..., alias="listPrice")
    price: Decimal
    terms_and_conditions: str = Field(..., alias="termsAndConditions")
    status: CampaignStatus
    from_date: str = Field(..., alias="fromDate")
    to_date: str = Field(..., alias="toDate")
    special_conditions: Optional[str] = Field(None, alias="specialConditions")
    is_valid: bool = Field(..., alias="isValid")
    version: int
    updated_at: Optional[str] = Field(None, alias="updatedAt")
    updated_by: Optional[str] = Field(None, alias="updatedBy")
    links: Optional[HATEOASLinks] = Field(None, alias="_links")

    class Config:
        populate_by_name = True

class AdminCampaignResponse(CampaignResponse):
    """Extended campaign response for admin views with disable/reactivate info"""
    created_at: str = Field(..., alias="createdAt")
    created_by: str = Field(..., alias="createdBy")
    disabled_at: Optional[str] = Field(None, alias="disabledAt")
    disabled_by: Optional[str] = Field(None, alias="disabledBy")
    disable_reason: Optional[str] = Field(None, alias="disableReason")
    reactivated_at: Optional[str] = Field(None, alias="reactivatedAt")
    reactivated_by: Optional[str] = Field(None, alias="reactivatedBy")

class CampaignListResponse(BaseModel):
    """List response with pagination"""
    items: List[CampaignResponse]
    count: int
    start_at: Optional[str] = Field(None, alias="startAt")
    more_available: bool = Field(..., alias="moreAvailable")

    class Config:
        populate_by_name = True

class HistoryRecordResponse(BaseModel):
    """Individual history record in response"""
    modification_id: str = Field(..., alias="modificationId")
    modified_at: str = Field(..., alias="modifiedAt")
    modified_by: str = Field(..., alias="modifiedBy")
    change_type: ChangeType = Field(..., alias="changeType")
    field_changed: str = Field(..., alias="fieldChanged")
    previous_value: str = Field(..., alias="previousValue")
    new_value: str = Field(..., alias="newValue")

    class Config:
        populate_by_name = True

class HistoryResponse(BaseModel):
    """Campaign history response with pagination"""
    campaign_code: str = Field(..., alias="campaignCode")
    history: List[HistoryRecordResponse]
    count: int
    start_at: Optional[str] = Field(None, alias="startAt")
    more_available: bool = Field(..., alias="moreAvailable")
    links: Optional[HATEOASLinks] = Field(None, alias="_links")

    class Config:
        populate_by_name = True

# =============================================================================
# REQUEST MODELS
# =============================================================================

class CreateCampaignRequest(BaseModel):
    """Request to create new campaign"""
    code: str = Field(..., min_length=3, max_length=50, pattern="^[A-Z0-9_-]+$")
    name: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    product_id: str = Field(..., alias="productId")
    discount_percent: int = Field(..., alias="discountPercent", ge=0, le=100)
    list_price: Decimal = Field(..., alias="listPrice", gt=0)
    terms_and_conditions: str = Field(..., alias="termsAndConditions", min_length=10, max_length=2000)
    from_date: str = Field(..., alias="fromDate")
    to_date: str = Field(..., alias="toDate")
    special_conditions: Optional[str] = Field(None, alias="specialConditions", max_length=500)

    class Config:
        populate_by_name = True

    @field_validator('to_date')
    @classmethod
    def validate_date_range(cls, v, info):
        """Validate that to_date is after from_date (BR-CMP-002)"""
        if 'from_date' in info.data:
            from_dt = datetime.fromisoformat(info.data['from_date'].replace('Z', '+00:00'))
            to_dt = datetime.fromisoformat(v.replace('Z', '+00:00'))
            if to_dt <= from_dt:
                raise ValueError('to_date must be after from_date')
        return v

class UpdateCampaignRequest(BaseModel):
    """Request to update existing campaign with optimistic locking"""
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    product_id: Optional[str] = Field(None, alias="productId")
    discount_percent: Optional[int] = Field(None, alias="discountPercent", ge=0, le=100)
    list_price: Optional[Decimal] = Field(None, alias="listPrice", gt=0)
    terms_and_conditions: Optional[str] = Field(None, alias="termsAndConditions", min_length=10, max_length=2000)
    from_date: Optional[str] = Field(None, alias="fromDate")
    to_date: Optional[str] = Field(None, alias="toDate")
    special_conditions: Optional[str] = Field(None, alias="specialConditions", max_length=500)
    version: int = Field(..., description="Required for optimistic locking")

    class Config:
        populate_by_name = True

    @model_validator(mode='after')
    def validate_at_least_one_field(self):
        """Ensure at least one field is being updated"""
        updatable_fields = ['name', 'description', 'product_id', 'discount_percent',
                          'list_price', 'terms_and_conditions', 'from_date',
                          'to_date', 'special_conditions']
        if not any(getattr(self, field) is not None for field in updatable_fields):
            raise ValueError('At least one field must be provided for update')
        return self

class DisableCampaignRequest(BaseModel):
    """Request to disable a campaign"""
    reason: Optional[str] = Field(None, max_length=500, description="Optional reason for disabling")

    class Config:
        populate_by_name = True

class ReactivateCampaignRequest(BaseModel):
    """Request to reactivate a disabled campaign"""
    to_date: Optional[str] = Field(None, alias="toDate", description="Optional new end date (must be in future)")

    class Config:
        populate_by_name = True

    @field_validator('to_date')
    @classmethod
    def validate_future_date(cls, v):
        """Validate that to_date is in the future if provided (BR-CMP-014)"""
        if v is not None:
            to_dt = datetime.fromisoformat(v.replace('Z', '+00:00'))
            if to_dt <= datetime.now(to_dt.tzinfo):
                raise ValueError('to_date must be in the future')
        return v

# =============================================================================
# EXCEPTION MODELS
# =============================================================================

class ErrorResponse(BaseModel):
    """Standard error response"""
    error: str
    message: str
    details: Optional[Dict[str, Any]] = None

class VersionConflictResponse(ErrorResponse):
    """Error response for optimistic locking conflicts"""
    current_version: int = Field(..., alias="currentVersion")
    expected_version: int = Field(..., alias="expectedVersion")

    class Config:
        populate_by_name = True
```

---

## 6. REST API Operations

### 6.1 List Campaigns

**Endpoint**: `GET /v1.0/campaigns`

**Description**: Retrieve all active campaigns available for viewing.

**Authentication**: None (public endpoint)

**Request Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| status | string | No | Filter by status (DRAFT, ACTIVE, EXPIRED) |

**Request Headers**:
```
Accept: application/json
```

**Request Example**:
```http
GET /v1.0/campaigns HTTP/1.1
Host: api.kimmyai.io
Accept: application/json
```

**Success Response (200 OK)**:

```json
{
  "campaigns": [
    {
      "code": "SUMMER2025",
      "name": "Summer Sale 2025",
      "productId": "PROD-002",
      "discountPercent": 20,
      "listPrice": 1500.00,
      "price": 1200.00,
      "termsAndConditions": "Valid for new customers only.",
      "status": "ACTIVE",
      "fromDate": "2025-06-01T00:00:00Z",
      "toDate": "2025-08-31T23:59:59Z",
      "specialConditions": "Minimum purchase of R500 required",
      "isValid": true
    },
    {
      "code": "NEWYEAR2025",
      "name": "New Year Special",
      "productId": "PROD-001",
      "discountPercent": 15,
      "listPrice": 95.00,
      "price": 80.75,
      "termsAndConditions": "Limited time offer.",
      "status": "ACTIVE",
      "fromDate": "2025-01-01T00:00:00Z",
      "toDate": "2025-01-31T23:59:59Z",
      "specialConditions": null,
      "isValid": true
    }
  ],
  "count": 2
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |
| 503 | Service Unavailable | `{"error": "Service unavailable", "message": "DynamoDB is temporarily unavailable"}` |

**Response Schema**:

```json
{
  "type": "object",
  "properties": {
    "campaigns": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "code": {"type": "string"},
          "name": {"type": "string"},
          "productId": {"type": "string"},
          "discountPercent": {"type": "integer", "minimum": 0, "maximum": 100},
          "listPrice": {"type": "number"},
          "price": {"type": "number"},
          "termsAndConditions": {"type": "string"},
          "status": {"type": "string", "enum": ["DRAFT", "ACTIVE", "EXPIRED"]},
          "fromDate": {"type": "string", "format": "date-time"},
          "toDate": {"type": "string", "format": "date-time"},
          "specialConditions": {"type": "string", "nullable": true},
          "isValid": {"type": "boolean"}
        },
        "required": ["code", "name", "productId", "discountPercent", "listPrice", "price", "termsAndConditions", "status", "fromDate", "toDate", "isValid"]
      }
    },
    "count": {"type": "integer"}
  },
  "required": ["campaigns", "count"]
}
```

**Business Rules**:
- Only campaigns with `active=true` are returned
- Campaign status is validated against current date
- `isValid` is true only for ACTIVE campaigns within date range
- Campaigns are returned sorted by fromDate (newest first)
- Empty array returned if no active campaigns exist

**Performance Considerations**:
- Response time target: <300ms (p95)
- Caching: CloudFront cache for 5 minutes
- DynamoDB: Scan operation with FilterExpression

**Example cURL**:
```bash
curl -X GET "https://api.kimmyai.io/v1.0/campaigns" \
  -H "Accept: application/json"
```

**Example JavaScript (Fetch)**:
```javascript
fetch('https://api.kimmyai.io/v1.0/campaigns', {
  method: 'GET',
  headers: {
    'Accept': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

**Example Python (Requests)**:
```python
import requests

response = requests.get(
    'https://api.kimmyai.io/v1.0/campaigns',
    headers={'Accept': 'application/json'}
)

if response.status_code == 200:
    campaigns = response.json()
    print(f"Found {campaigns['count']} campaigns")
else:
    print(f"Error: {response.status_code}")
```

### 6.2 Get Campaign By Code

**Endpoint**: `GET /v1.0/campaigns/{code}`

**Description**: Retrieve a specific campaign by its unique code with status validation.

**Authentication**: None (public endpoint)

**Path Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| code | string | Yes | Unique campaign code (e.g., SUMMER2025) |

**Request Headers**:
```
Accept: application/json
```

**Request Example**:
```http
GET /v1.0/campaigns/SUMMER2025 HTTP/1.1
Host: api.kimmyai.io
Accept: application/json
```

**Success Response (200 OK)**:

```json
{
  "campaign": {
    "code": "SUMMER2025",
    "name": "Summer Sale 2025",
    "productId": "PROD-002",
    "discountPercent": 20,
    "listPrice": 1500.00,
    "price": 1200.00,
    "termsAndConditions": "Valid for new customers only. Cannot be combined with other offers.",
    "status": "ACTIVE",
    "fromDate": "2025-06-01T00:00:00Z",
    "toDate": "2025-08-31T23:59:59Z",
    "specialConditions": "Minimum purchase of R500 required",
    "isValid": true
  }
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 404 | Campaign Not Found | `{"error": "Campaign not found", "message": "Campaign with code SUMMER2025 does not exist or is inactive"}` |
| 400 | Invalid Campaign Code | `{"error": "Invalid request", "message": "Campaign code is required"}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Response Schema**:

```json
{
  "type": "object",
  "properties": {
    "campaign": {
      "type": "object",
      "properties": {
        "code": {"type": "string"},
        "name": {"type": "string"},
        "productId": {"type": "string"},
        "discountPercent": {"type": "integer"},
        "listPrice": {"type": "number"},
        "price": {"type": "number"},
        "termsAndConditions": {"type": "string"},
        "status": {"type": "string", "enum": ["DRAFT", "ACTIVE", "EXPIRED"]},
        "fromDate": {"type": "string", "format": "date-time"},
        "toDate": {"type": "string", "format": "date-time"},
        "specialConditions": {"type": "string", "nullable": true},
        "isValid": {"type": "boolean"}
      },
      "required": ["code", "name", "productId", "discountPercent", "listPrice", "price", "termsAndConditions", "status", "fromDate", "toDate", "isValid"]
    }
  },
  "required": ["campaign"]
}
```

**Business Rules**:
- Only campaigns with `active=true` can be retrieved
- Inactive campaigns return 404 Not Found
- Status is dynamically calculated based on current date:
  - `DRAFT`: fromDate is in the future
  - `ACTIVE`: current date is between fromDate and toDate
  - `EXPIRED`: toDate is in the past
- `isValid` is true only when status is ACTIVE
- `price` is calculated as: `listPrice * (1 - discountPercent/100)`

**Performance Considerations**:
- Response time target: <100ms (p95)
- Caching: CloudFront cache for 5 minutes per campaign
- DynamoDB: GetItem operation (single item lookup)

**Example cURL**:
```bash
curl -X GET "https://api.kimmyai.io/v1.0/campaigns/SUMMER2025" \
  -H "Accept: application/json"
```

**Example JavaScript (Fetch)**:
```javascript
const campaignCode = 'SUMMER2025';

fetch(`https://api.kimmyai.io/v1.0/campaigns/${campaignCode}`, {
  method: 'GET',
  headers: {
    'Accept': 'application/json'
  }
})
  .then(response => {
    if (response.status === 404) {
      throw new Error('Campaign not found');
    }
    return response.json();
  })
  .then(data => console.log(data.campaign))
  .catch(error => console.error('Error:', error));
```

**Example Python (Requests)**:
```python
import requests

campaign_code = 'SUMMER2025'
response = requests.get(
    f'https://api.kimmyai.io/v1.0/campaigns/{campaign_code}',
    headers={'Accept': 'application/json'}
)

if response.status_code == 200:
    campaign = response.json()['campaign']
    print(f"Campaign: {campaign['name']} - {campaign['discountPercent']}% off")
    print(f"Price: {campaign['listPrice']} -> {campaign['price']}")
elif response.status_code == 404:
    print(f"Campaign {campaign_code} not found")
else:
    print(f"Error: {response.status_code}")
```

### 6.3 Create Campaign

**Endpoint**: `POST /v1.0/campaigns`

**Description**: Create a new campaign in the system.

**Authentication**: Admin role required (future implementation)

**Request Headers**:
```
Content-Type: application/json
Accept: application/json
```

**Request Body**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| code | string | Yes | Unique campaign code (uppercase, alphanumeric, 3-50 chars) |
| name | string | Yes | Campaign display name |
| productId | string | Yes | Associated product ID |
| discountPercent | integer | Yes | Discount percentage (0-100) |
| listPrice | number | Yes | Original price before discount |
| termsAndConditions | string | Yes | Campaign terms and conditions |
| fromDate | string | Yes | Start date (ISO 8601) |
| toDate | string | Yes | End date (ISO 8601) |
| specialConditions | string | No | Additional conditions |

**Request Example**:
```http
POST /v1.0/campaigns HTTP/1.1
Host: api.kimmyai.io
Content-Type: application/json
Accept: application/json

{
  "code": "WINTER2025",
  "name": "Winter Warmup Sale",
  "productId": "PROD-003",
  "discountPercent": 25,
  "listPrice": 3500.00,
  "termsAndConditions": "Valid for all customers. One use per customer.",
  "fromDate": "2025-07-01T00:00:00Z",
  "toDate": "2025-08-31T23:59:59Z",
  "specialConditions": "Cannot be combined with loyalty discounts"
}
```

**Success Response (201 Created)**:

```json
{
  "campaign": {
    "code": "WINTER2025",
    "name": "Winter Warmup Sale",
    "productId": "PROD-003",
    "discountPercent": 25,
    "listPrice": 3500.00,
    "price": 2625.00,
    "termsAndConditions": "Valid for all customers. One use per customer.",
    "status": "DRAFT",
    "fromDate": "2025-07-01T00:00:00Z",
    "toDate": "2025-08-31T23:59:59Z",
    "specialConditions": "Cannot be combined with loyalty discounts",
    "isValid": false,
    "createdAt": "2025-12-31T10:30:00Z"
  }
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 400 | Invalid Request | `{"error": "Invalid request", "message": "Missing required field: code"}` |
| 400 | Validation Error | `{"error": "Validation error", "message": "Discount percent must be between 0 and 100"}` |
| 400 | Duplicate Code | `{"error": "Validation error", "message": "Campaign code WINTER2025 already exists"}` |
| 400 | Invalid Date Range | `{"error": "Validation error", "message": "toDate must be after fromDate"}` |
| 401 | Unauthorized | `{"error": "Unauthorized", "message": "Admin authentication required"}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Business Rules**:
- Campaign code must be unique within the system
- Code must be uppercase alphanumeric with underscores/hyphens only
- `price` is auto-calculated: `listPrice * (1 - discountPercent/100)`
- `status` is auto-determined based on dates:
  - `DRAFT` if fromDate is in the future
  - `ACTIVE` if current date is between fromDate and toDate
  - `EXPIRED` if toDate is in the past
- `active` flag defaults to `true`
- `createdAt` timestamp is auto-generated (ISO 8601)
- toDate must be after fromDate

**Validation Rules**:
- `code`: 3-50 characters, uppercase alphanumeric with underscores/hyphens
- `name`: 3-100 characters
- `discountPercent`: Integer, 0-100
- `listPrice`: Decimal, min: 0.01, max: 999999.99
- `termsAndConditions`: 10-1000 characters
- `fromDate`, `toDate`: ISO 8601 format
- `specialConditions`: Optional, max 500 characters

**Performance Considerations**:
- Response time target: <200ms (p95)
- DynamoDB: GetItem (check exists) + PutItem operation

**Example cURL**:
```bash
curl -X POST "https://api.kimmyai.io/v1.0/campaigns" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{
    "code": "WINTER2025",
    "name": "Winter Warmup Sale",
    "productId": "PROD-003",
    "discountPercent": 25,
    "listPrice": 3500.00,
    "termsAndConditions": "Valid for all customers. One use per customer.",
    "fromDate": "2025-07-01T00:00:00Z",
    "toDate": "2025-08-31T23:59:59Z"
  }'
```

**Example JavaScript (Fetch)**:
```javascript
const newCampaign = {
  code: "WINTER2025",
  name: "Winter Warmup Sale",
  productId: "PROD-003",
  discountPercent: 25,
  listPrice: 3500.00,
  termsAndConditions: "Valid for all customers. One use per customer.",
  fromDate: "2025-07-01T00:00:00Z",
  toDate: "2025-08-31T23:59:59Z"
};

fetch('https://api.kimmyai.io/v1.0/campaigns', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  body: JSON.stringify(newCampaign)
})
  .then(response => {
    if (response.status === 201) {
      return response.json();
    }
    throw new Error(`HTTP ${response.status}`);
  })
  .then(data => console.log('Created campaign:', data.campaign))
  .catch(error => console.error('Error:', error));
```

**Example Python (Requests)**:
```python
import requests

new_campaign = {
    "code": "WINTER2025",
    "name": "Winter Warmup Sale",
    "productId": "PROD-003",
    "discountPercent": 25,
    "listPrice": 3500.00,
    "termsAndConditions": "Valid for all customers. One use per customer.",
    "fromDate": "2025-07-01T00:00:00Z",
    "toDate": "2025-08-31T23:59:59Z"
}

response = requests.post(
    'https://api.kimmyai.io/v1.0/campaigns',
    headers={
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    },
    json=new_campaign
)

if response.status_code == 201:
    campaign = response.json()['campaign']
    print(f"Created campaign: {campaign['code']}")
    print(f"Calculated price: {campaign['listPrice']} -> {campaign['price']}")
elif response.status_code == 400:
    error = response.json()
    print(f"Validation error: {error['message']}")
else:
    print(f"Error: {response.status_code}")
```

### 6.4 Update Campaign (Admin)

**Endpoint**: `PUT /v1.0/admin/campaigns/{code}`

**Description**: Update an existing campaign with optimistic locking and modification history tracking.

**Authentication**: Admin role required (Cognito JWT)

**Path Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| code | string | Yes | Unique campaign code (immutable - cannot be changed) |

**Request Headers**:
```
Authorization: Bearer {jwt_token}
Content-Type: application/json
Accept: application/json
```

**Request Body**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| name | string | No | Campaign display name (3-100 chars) |
| description | string | No | Campaign description (max 500 chars) |
| productId | string | No | Associated product ID |
| discountPercent | integer | No | Discount percentage (0-100) |
| listPrice | number | No | Original price before discount (> 0) |
| termsAndConditions | string | No | Campaign terms (10-2000 chars) |
| fromDate | string | No | Start date (ISO 8601) |
| toDate | string | No | End date (ISO 8601) |
| specialConditions | string | No | Additional conditions (max 500 chars) |
| version | integer | **Yes** | **Required for optimistic locking** |

**Request Example**:
```http
PUT /v1.0/admin/campaigns/SUMMER2026 HTTP/1.1
Host: api.kimmyai.io
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Content-Type: application/json
Accept: application/json

{
  "name": "Summer Sale 2026 - Extended!",
  "discountPercent": 30,
  "termsAndConditions": "Extended offer! Valid for all customers.",
  "toDate": "2026-09-30T23:59:59Z",
  "version": 3
}
```

**Success Response (200 OK)**:

```json
{
  "code": "SUMMER2026",
  "name": "Summer Sale 2026 - Extended!",
  "description": "Get 30% off all hosting packages this summer!",
  "productId": "PROD-002",
  "discountPercent": 30,
  "listPrice": 1500.00,
  "price": 1050.00,
  "termsAndConditions": "Extended offer! Valid for all customers.",
  "status": "ACTIVE",
  "fromDate": "2026-06-01T00:00:00Z",
  "toDate": "2026-09-30T23:59:59Z",
  "specialConditions": "Minimum purchase of R500 required",
  "isValid": true,
  "version": 4,
  "updatedAt": "2026-01-18T14:30:00Z",
  "updatedBy": "admin@example.com",
  "_links": {
    "self": "/v1.0/admin/campaigns/SUMMER2026",
    "history": "/v1.0/admin/campaigns/SUMMER2026/history",
    "disable": "/v1.0/admin/campaigns/SUMMER2026/disable"
  }
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 400 | Invalid Request | `{"error": "Invalid request", "message": "At least one field must be provided for update"}` |
| 400 | Business Rule Violation | `{"error": "Business rule violation", "message": "Cannot modify campaign end date to a past date for active campaigns (BR-CMP-008)"}` |
| 400 | Code Immutable | `{"error": "Business rule violation", "message": "Campaign code cannot be modified after creation (BR-CMP-009)"}` |
| 401 | Unauthorized | `{"error": "Unauthorized", "message": "Admin authentication required"}` |
| 403 | Forbidden | `{"error": "Forbidden", "message": "Insufficient permissions"}` |
| 404 | Campaign Not Found | `{"error": "Campaign not found", "message": "Campaign with code SUMMER2026 does not exist"}` |
| 409 | Version Conflict | `{"error": "Version conflict", "message": "Campaign was modified by another user", "currentVersion": 4, "expectedVersion": 3}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Business Rules (BR-CMP-005 to BR-CMP-010)**:
- **BR-CMP-005**: All modifications logged with user, timestamp, and previous values
- **BR-CMP-006**: Discount changes take effect immediately for new orders
- **BR-CMP-007**: Existing cart items retain original discount until checkout
- **BR-CMP-008**: Active campaign end date cannot be set to past date
- **BR-CMP-009**: Campaign code is immutable after creation
- **BR-CMP-010**: Updating an expired campaign does NOT reactivate it

**Optimistic Locking**:
- `version` field is **required** in request body
- If current version in DB differs from provided version, returns 409 Conflict
- On successful update, version is incremented by 1
- Client must retry with new version if conflict occurs

**Modification History**:
- Each changed field creates a separate history record
- Records include: timestamp, user, field name, old value, new value
- History is append-only (immutable audit trail)

**Cache Invalidation**:
- CloudFront cache invalidated for `/v1.0/campaigns` and `/v1.0/campaigns/{code}`
- Invalidation completes within 2 seconds

**Performance Considerations**:
- Response time target: <500ms (p95)
- DynamoDB: TransactWriteItems (campaign update + history records)
- CloudFront: CreateInvalidation API call

**Example cURL**:
```bash
curl -X PUT "https://api.kimmyai.io/v1.0/admin/campaigns/SUMMER2026" \
  -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIs..." \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{
    "discountPercent": 30,
    "toDate": "2026-09-30T23:59:59Z",
    "version": 3
  }'
```

**Example Python (Requests)**:
```python
import requests

campaign_code = 'SUMMER2026'
updates = {
    "discountPercent": 30,
    "toDate": "2026-09-30T23:59:59Z",
    "version": 3  # Required for optimistic locking
}

response = requests.put(
    f'https://api.kimmyai.io/v1.0/admin/campaigns/{campaign_code}',
    headers={
        'Authorization': 'Bearer eyJhbGciOiJSUzI1NiIs...',
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    },
    json=updates
)

if response.status_code == 200:
    campaign = response.json()
    print(f"Updated campaign: {campaign['code']}")
    print(f"New version: {campaign['version']}")
elif response.status_code == 409:
    error = response.json()
    print(f"Version conflict! Current: {error['currentVersion']}, Expected: {error['expectedVersion']}")
    # Retry with new version
elif response.status_code == 404:
    print(f"Campaign {campaign_code} not found")
else:
    print(f"Error: {response.status_code}")
```

---

### 6.5 Disable Campaign (Admin)

**Endpoint**: `PATCH /v1.0/admin/campaigns/{code}/disable`

**Description**: Disable an active, scheduled, or expired campaign. Disabled campaigns are hidden from customers but preserved for historical reference.

**Authentication**: Admin role required (Cognito JWT)

**Path Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| code | string | Yes | Unique campaign code |

**Request Headers**:
```
Authorization: Bearer {jwt_token}
Content-Type: application/json
Accept: application/json
```

**Request Body**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| reason | string | No | Optional reason for disabling (max 500 chars) |

**Request Example**:
```http
PATCH /v1.0/admin/campaigns/SUMMER2026/disable HTTP/1.1
Host: api.kimmyai.io
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Content-Type: application/json
Accept: application/json

{
  "reason": "Campaign underperforming - pausing for review"
}
```

**Success Response (200 OK)**:

```json
{
  "code": "SUMMER2026",
  "name": "Summer Sale 2026",
  "status": "DISABLED",
  "disabledAt": "2026-01-18T15:00:00Z",
  "disabledBy": "admin@example.com",
  "disableReason": "Campaign underperforming - pausing for review",
  "version": 5,
  "_links": {
    "self": "/v1.0/admin/campaigns/SUMMER2026",
    "reactivate": "/v1.0/admin/campaigns/SUMMER2026/reactivate",
    "history": "/v1.0/admin/campaigns/SUMMER2026/history"
  }
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 400 | Invalid Status Transition | `{"error": "Invalid status transition", "message": "Cannot disable a campaign in DRAFT status (BR-CMP-013)"}` |
| 400 | Already Disabled | `{"error": "Invalid status transition", "message": "Campaign is already disabled"}` |
| 401 | Unauthorized | `{"error": "Unauthorized", "message": "Admin authentication required"}` |
| 404 | Campaign Not Found | `{"error": "Campaign not found", "message": "Campaign with code SUMMER2026 does not exist"}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Business Rules (BR-CMP-011 to BR-CMP-018)**:
- **BR-CMP-011**: Disabled campaigns hidden from all customer-facing pages
- **BR-CMP-012**: Disabled campaigns retain all data for reporting and audit
- **BR-CMP-013**: Only ACTIVE, SCHEDULED, and EXPIRED campaigns can be disabled
- **BR-CMP-015**: Cart items with discount honoured for 24 hours after disable
- **BR-CMP-016**: Disabled campaigns cannot be used for new orders
- **BR-CMP-017**: Disable reason is optional but recommended
- **BR-CMP-018**: Each disable/reactivate transition is logged

**Valid Status Transitions for Disable**:
- ACTIVE -> DISABLED
- SCHEDULED -> DISABLED
- EXPIRED -> DISABLED

**Invalid Status Transitions**:
- DRAFT -> DISABLED (400 Bad Request)
- DISABLED -> DISABLED (400 Bad Request)

**Grace Period (BR-CMP-015)**:
- When campaign is disabled, Cart Service is notified
- Cart items with this campaign's discount are honoured for 24 hours or until checkout
- After grace period, cart items revert to full price

**Example cURL**:
```bash
curl -X PATCH "https://api.kimmyai.io/v1.0/admin/campaigns/SUMMER2026/disable" \
  -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIs..." \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{"reason": "Campaign underperforming - pausing for review"}'
```

---

### 6.6 Reactivate Campaign (Admin)

**Endpoint**: `PATCH /v1.0/admin/campaigns/{code}/reactivate`

**Description**: Reactivate a previously disabled campaign. The campaign will become ACTIVE or SCHEDULED based on its dates.

**Authentication**: Admin role required (Cognito JWT)

**Path Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| code | string | Yes | Unique campaign code |

**Request Headers**:
```
Authorization: Bearer {jwt_token}
Content-Type: application/json
Accept: application/json
```

**Request Body**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| toDate | string | No | Optional new end date (must be in future, ISO 8601) |

**Request Example**:
```http
PATCH /v1.0/admin/campaigns/SUMMER2026/reactivate HTTP/1.1
Host: api.kimmyai.io
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Content-Type: application/json
Accept: application/json

{
  "toDate": "2026-09-30T23:59:59Z"
}
```

**Success Response (200 OK)**:

```json
{
  "code": "SUMMER2026",
  "name": "Summer Sale 2026",
  "status": "ACTIVE",
  "fromDate": "2026-06-01T00:00:00Z",
  "toDate": "2026-09-30T23:59:59Z",
  "reactivatedAt": "2026-01-18T16:00:00Z",
  "reactivatedBy": "admin@example.com",
  "version": 6,
  "_links": {
    "self": "/v1.0/admin/campaigns/SUMMER2026",
    "disable": "/v1.0/admin/campaigns/SUMMER2026/disable",
    "history": "/v1.0/admin/campaigns/SUMMER2026/history"
  }
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 400 | Not Disabled | `{"error": "Invalid status transition", "message": "Campaign is not disabled"}` |
| 400 | End Date Required | `{"error": "Validation error", "message": "End date must be in the future to reactivate (BR-CMP-014)"}` |
| 400 | Invalid End Date | `{"error": "Validation error", "message": "Provided end date must be in the future"}` |
| 401 | Unauthorized | `{"error": "Unauthorized", "message": "Admin authentication required"}` |
| 404 | Campaign Not Found | `{"error": "Campaign not found", "message": "Campaign with code SUMMER2026 does not exist"}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Business Rules**:
- **BR-CMP-014**: End date must be in the future to reactivate
- Only DISABLED campaigns can be reactivated
- New status is calculated based on dates:
  - If `fromDate > now`: status = SCHEDULED
  - If `fromDate <= now <= toDate`: status = ACTIVE
- If current `toDate` is in the past, a new `toDate` is required in request
- Previous disable information is cleared (disabledAt, disabledBy, disableReason)
- Reactivation is logged in history

**Example cURL**:
```bash
curl -X PATCH "https://api.kimmyai.io/v1.0/admin/campaigns/SUMMER2026/reactivate" \
  -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIs..." \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{"toDate": "2026-09-30T23:59:59Z"}'
```

---

### 6.7 Get Campaign History (Admin)

**Endpoint**: `GET /v1.0/admin/campaigns/{code}/history`

**Description**: Retrieve the modification history of a campaign with pagination. Returns all changes including updates, disables, and reactivations.

**Authentication**: Admin role required (Cognito JWT)

**Path Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| code | string | Yes | Unique campaign code |

**Query Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| limit | integer | No | Max records to return (default: 20, max: 100) |
| startAt | string | No | Pagination token from previous response |

**Request Headers**:
```
Authorization: Bearer {jwt_token}
Accept: application/json
```

**Request Example**:
```http
GET /v1.0/admin/campaigns/SUMMER2026/history?limit=10 HTTP/1.1
Host: api.kimmyai.io
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
Accept: application/json
```

**Success Response (200 OK)**:

```json
{
  "campaignCode": "SUMMER2026",
  "history": [
    {
      "modificationId": "mod-uuid-001",
      "modifiedAt": "2026-01-18T16:00:00Z",
      "modifiedBy": "admin@example.com",
      "changeType": "REACTIVATE",
      "fieldChanged": "status",
      "previousValue": "DISABLED",
      "newValue": "ACTIVE"
    },
    {
      "modificationId": "mod-uuid-002",
      "modifiedAt": "2026-01-18T15:00:00Z",
      "modifiedBy": "admin@example.com",
      "changeType": "DISABLE",
      "fieldChanged": "status",
      "previousValue": "ACTIVE",
      "newValue": "DISABLED"
    },
    {
      "modificationId": "mod-uuid-003",
      "modifiedAt": "2026-01-18T14:30:00Z",
      "modifiedBy": "marketing@example.com",
      "changeType": "UPDATE",
      "fieldChanged": "discountPercent",
      "previousValue": "20",
      "newValue": "25"
    }
  ],
  "count": 3,
  "moreAvailable": true,
  "startAt": "eyJQSyI6IkNBTVBBSUdOI1NVTU1FUjIwMjYi...",
  "_links": {
    "self": "/v1.0/admin/campaigns/SUMMER2026/history?limit=10",
    "next": "/v1.0/admin/campaigns/SUMMER2026/history?limit=10&startAt=eyJQSyI6IkNBTVBBSUdOI1NVTU1FUjIwMjYi...",
    "campaign": "/v1.0/admin/campaigns/SUMMER2026"
  }
}
```

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 401 | Unauthorized | `{"error": "Unauthorized", "message": "Admin authentication required"}` |
| 404 | Campaign Not Found | `{"error": "Campaign not found", "message": "Campaign with code SUMMER2026 does not exist"}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Pagination**:
- Results sorted by `modifiedAt` descending (newest first)
- Use `startAt` token from previous response for next page
- `moreAvailable: true` indicates more records exist

**Performance Considerations**:
- Response time target: <500ms (p95)
- DynamoDB: Query on PK with SK begins_with `HISTORY#`
- History records stored in same partition as campaign for efficient queries

**Example cURL**:
```bash
curl -X GET "https://api.kimmyai.io/v1.0/admin/campaigns/SUMMER2026/history?limit=10" \
  -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIs..." \
  -H "Accept: application/json"
```

---

### 6.8 Delete Campaign (Soft Delete)

**Endpoint**: `DELETE /v1.0/campaigns/{code}`

**Description**: Soft delete a campaign by setting its active flag to false. The campaign remains in the database but is excluded from public listings.

**Authentication**: Admin role required (future implementation)

**Path Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| code | string | Yes | Unique campaign code |

**Request Headers**:
```
Accept: application/json
```

**Request Example**:
```http
DELETE /v1.0/campaigns/SUMMER2025 HTTP/1.1
Host: api.kimmyai.io
Accept: application/json
```

**Success Response (204 No Content)**:

No response body returned. Status code 204 indicates successful deletion.

**Error Responses**:

| Status Code | Description | Response Body |
|-------------|-------------|---------------|
| 401 | Unauthorized | `{"error": "Unauthorized", "message": "Admin authentication required"}` |
| 404 | Campaign Not Found | `{"error": "Campaign not found", "message": "Campaign with code SUMMER2025 does not exist"}` |
| 500 | Internal Server Error | `{"error": "Internal server error", "message": "An unexpected error occurred"}` |

**Business Rules**:
- This is a soft delete operation (sets `active=false`)
- Campaign data is retained in DynamoDB
- Deleted campaigns do not appear in GET /v1.0/campaigns listings
- Deleted campaigns return 404 on GET /v1.0/campaigns/{code}
- Deleted campaigns can be restored by updating `active=true`
- Hard delete is not supported (data retention policy)

**Performance Considerations**:
- Response time target: <100ms (p95)
- DynamoDB: GetItem + UpdateItem operations

**Example cURL**:
```bash
curl -X DELETE "https://api.kimmyai.io/v1.0/campaigns/SUMMER2025" \
  -H "Accept: application/json" \
  -w "HTTP Status: %{http_code}\n"
```

**Example JavaScript (Fetch)**:
```javascript
const campaignCode = 'SUMMER2025';

fetch(`https://api.kimmyai.io/v1.0/campaigns/${campaignCode}`, {
  method: 'DELETE',
  headers: {
    'Accept': 'application/json'
  }
})
  .then(response => {
    if (response.status === 204) {
      console.log('Campaign deleted successfully');
    } else if (response.status === 404) {
      throw new Error('Campaign not found');
    } else {
      throw new Error(`HTTP ${response.status}`);
    }
  })
  .catch(error => console.error('Error:', error));
```

**Example Python (Requests)**:
```python
import requests

campaign_code = 'SUMMER2025'

response = requests.delete(
    f'https://api.kimmyai.io/v1.0/campaigns/{campaign_code}',
    headers={'Accept': 'application/json'}
)

if response.status_code == 204:
    print(f"Campaign {campaign_code} deleted successfully")
elif response.status_code == 404:
    print(f"Campaign {campaign_code} not found")
else:
    print(f"Error: {response.status_code}")
```

**Restoration Example**:

To restore a soft-deleted campaign, use the Update Campaign endpoint:

```bash
curl -X PUT "https://api.kimmyai.io/v1.0/campaigns/SUMMER2025" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{"active": true}'
```

---

## 7. Messaging and Notifications

No email notifications for this service.

---

## 7.5 Business Rules Reference

This section consolidates all business rules from the BRS and HLD for implementation reference.

### 7.5.1 Update Promotions Business Rules (Epic 3)

| Rule ID | Rule | Implementation |
|---------|------|----------------|
| BR-CMP-005 | All modifications must be logged with user identity, timestamp, and previous values | History records created for each field change using DynamoDB TransactWriteItems |
| BR-CMP-006 | Discount changes take effect immediately for new orders | CloudFront cache invalidation within 2 seconds |
| BR-CMP-007 | Existing cart items retain original discount until checkout | Cart Service reads discount at add-to-cart time, stores in cart item |
| BR-CMP-008 | Active campaign end date cannot be set to past date | Validation in UpdateCampaignRequest, 400 Bad Request if violated |
| BR-CMP-009 | Campaign code is immutable after creation | Code field excluded from update operations, 400 Bad Request if attempted |
| BR-CMP-010 | Updating an expired campaign does not reactivate it | Status recalculated from dates, EXPIRED remains EXPIRED |

### 7.5.2 Disable Promotions Business Rules (Epic 4)

| Rule ID | Rule | Implementation |
|---------|------|----------------|
| BR-CMP-011 | Disabled campaigns hidden from all customer-facing pages | Public API filters out DISABLED status campaigns |
| BR-CMP-012 | Disabled campaigns retain all data for reporting | No data deletion, only status change to DISABLED |
| BR-CMP-013 | Only ACTIVE, SCHEDULED, EXPIRED campaigns can be disabled | Status transition validation, 400 Bad Request for DRAFT/DISABLED |
| BR-CMP-014 | End date must be in future to reactivate | Validation in ReactivateCampaignRequest, new toDate required if past |
| BR-CMP-015 | Cart items with discount honoured for 24 hours after disable | Cart Service notified with gracePeriodEnd timestamp |
| BR-CMP-016 | Disabled campaigns cannot be used for new orders | Order Service checks campaign status before applying discount |
| BR-CMP-017 | Disable reason is optional but recommended | Optional field in DisableCampaignRequest |
| BR-CMP-018 | Each disable/reactivate transition logged | History record with changeType=DISABLE/REACTIVATE |

### 7.5.3 Status Lifecycle Rules

| Status | Entry Conditions | Exit Transitions |
|--------|------------------|------------------|
| DRAFT | Manual creation | -> SCHEDULED (when fromDate set in future) |
| SCHEDULED | fromDate > current date | -> ACTIVE (when fromDate reached), -> DISABLED (admin action) |
| ACTIVE | fromDate <= now <= toDate | -> EXPIRED (when toDate passed), -> DISABLED (admin action) |
| DISABLED | Admin disable action | -> ACTIVE (reactivate, if dates allow), -> SCHEDULED (reactivate, if fromDate in future) |
| EXPIRED | toDate < current date | -> DISABLED (admin action for archiving) |

### 7.5.4 Optimistic Locking Rules

| Rule | Implementation |
|------|----------------|
| Version starts at 1 | Initialised on campaign creation |
| Version incremented on update | Atomic increment using DynamoDB UpdateExpression |
| Version checked before write | ConditionExpression: version = expectedVersion |
| Conflict returns 409 | VersionConflictException with currentVersion and expectedVersion |
| Client must retry | Re-fetch campaign, resolve conflicts, retry with new version |

### 7.5.5 Cache Invalidation Rules

| Trigger | Paths Invalidated | SLA |
|---------|-------------------|-----|
| Update campaign | /v1.0/campaigns, /v1.0/campaigns/{code} | < 2 seconds |
| Disable campaign | /v1.0/campaigns, /v1.0/campaigns/{code} | < 2 seconds |
| Reactivate campaign | /v1.0/campaigns, /v1.0/campaigns/{code} | < 2 seconds |
| Delete campaign | /v1.0/campaigns, /v1.0/campaigns/{code} | < 2 seconds |

---

## 8. NFRs (Non-Functional Requirements)

### 8.1 Performance Targets

| Metric | Target | Notes |
|--------|--------|-------|
| List campaigns API latency (p95) | < 300ms | GSI1 query with status filter |
| Get campaign API latency (p95) | < 100ms | Direct DynamoDB get_item |
| Create campaign API latency (p95) | < 250ms | Direct DynamoDB write with validation |
| Update campaign API latency (p95) | < 500ms | TransactWriteItems (campaign + history) + cache invalidation |
| Disable campaign API latency (p95) | < 300ms | Status update + history + cache invalidation |
| Reactivate campaign API latency (p95) | < 300ms | Status update + history + cache invalidation |
| Get history API latency (p95) | < 500ms | Query on PK with SK begins_with |
| Delete campaign API latency (p95) | < 150ms | Direct DynamoDB soft delete (update active=false) |
| Cold start | < 500ms | arm64 architecture |
| Cache hit ratio | > 90% | CloudFront caching |
| Cache invalidation time | < 2 seconds | CloudFront CreateInvalidation API |

### 8.2 Scalability Targets

| Metric | Target |
|--------|--------|
| Concurrent campaign operations | 100 operations/second |
| Concurrent admin users | 100 |
| Campaigns per tenant | 10,000 |
| Modification history records per campaign | Unlimited (auto-archived after 1 year) |
| Lambda concurrent executions | 100 per function (reserved) |
| DynamoDB read/write capacity | On-demand (auto-scaling) |

### 8.3 Availability and Reliability

| Metric | Target |
|--------|--------|
| API availability | 99.9% (SLA) |
| Campaign change processing success rate | 99.95% |
| Update operation success rate | > 99.5% |
| Disable/Reactivate operation success rate | > 99.5% |
| Data durability | 99.999999999% (DynamoDB) |
| Recovery Time Objective (RTO) | < 30 minutes |
| Recovery Point Objective (RPO) | < 1 minute |

### 8.4 Data Retention

| Data Type | Retention Period | Storage |
|-----------|------------------|---------|
| Campaign records | Indefinite | DynamoDB with PITR |
| Modification history | Indefinite (1 year active, then S3 archive) | DynamoDB + S3 Glacier |
| CloudWatch logs | 90 days | Log retention policy |
| Lambda function versions | 30 days | Automatic cleanup of old versions |
| CloudFront access logs | 30 days | CDN performance analysis |

---

## 9. Risks and Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| DynamoDB throttling | Medium | Low | On-demand capacity mode, reserved Lambda concurrency |
| Duplicate campaign creation | High | Low | Unique code check before insert, DynamoDB conditional writes |
| Invalid campaign data | Medium | Medium | Schema validation in API handler, Pydantic models |
| Stale campaign status | Medium | Medium | Dynamic status calculation based on current date |
| Expired campaign still shown | Medium | Low | Date validation on every read, cache invalidation |
| Price calculation errors | High | Low | Multi-layer validation, test coverage |
| Unauthorized campaign changes | High | Low | Cognito JWT validation, Admin role check |
| Concurrent update conflicts | Medium | Medium | Optimistic locking with version field, 409 Conflict response |
| Accidental campaign disable | High | Low | Confirmation UI + disable reason field (recommended) |
| Cache serving stale data | Medium | Low | Proactive CloudFront cache invalidation < 2 seconds |
| Audit trail tampering | High | Very Low | Append-only history records, no delete/update operations |
| Grace period violations | Medium | Low | 24-hour cart discount honour policy (BR-CMP-015) |
| History table growth | Low | Medium | Auto-archive to S3 after 1 year |
| Lambda timeout | Medium | Low | 30s timeout, CloudWatch alarms on duration |
| DynamoDB unavailable | High | Very Low | Multi-AZ deployment, automatic failover, PITR backups |
| API Gateway failures | High | Very Low | CloudWatch alarms, automatic retries with exponential backoff |
| Mass disable attack | Medium | Low | Rate limiting + CloudWatch alerting on unusual disable activity |

---

## 10. Tagging

| Tag | Value |
|-----|-------|
| Project | BBWS |
| Component | CampaignsLambda |
| CostCenter | BBWS-CPP |

---

## 11. Troubleshooting Playbook

| Issue | Resolution |
|-------|------------|
| Empty campaign list | Check DynamoDB for active campaigns with active=true |
| Campaign not found | Verify code in DynamoDB, check if active=false (soft deleted) |
| Wrong status | Check from_date/to_date values against current date |
| Price calculation wrong | Verify listPrice and discountPercent values |
| Create campaign fails | Validate request body against schema, check for duplicate code |
| Update conflicts | Check for concurrent updates, retry with exponential backoff |
| Unauthorized errors | Verify admin authentication (future implementation) |
| Validation errors | Check field constraints: discount 0-100, date format, code pattern |
| Status not updating | Verify date comparison logic, check timezone handling |

---

## 12. Security

### 12.1 Authentication and Authorization

**Public Endpoints** (no authentication):
- GET /v1.0/campaigns (list active campaigns for customers)
- GET /v1.0/campaigns/{code} (get campaign details for customers)

**Admin Endpoints** (Cognito JWT required):
- GET /v1.0/admin/campaigns (list all campaigns with all statuses)
- POST /v1.0/admin/campaigns (create campaign)
- PUT /v1.0/admin/campaigns/{code} (update campaign)
- PATCH /v1.0/admin/campaigns/{code}/disable (disable campaign)
- PATCH /v1.0/admin/campaigns/{code}/reactivate (reactivate campaign)
- GET /v1.0/admin/campaigns/{code}/history (get modification history)
- DELETE /v1.0/admin/campaigns/{code} (delete campaign)

### 12.2 Security Measures

| Measure | Implementation |
|---------|---------------|
| Rate Limiting | 100 req/s public, 50 req/s admin (API Gateway) |
| Input Validation | Pydantic models, field-level validation |
| Encryption at Rest | DynamoDB AES-256 (AWS managed keys) |
| Encryption in Transit | TLS 1.2+ for all API calls |
| Optimistic Locking | Version field prevents concurrent update conflicts |
| Audit Logging | All modifications logged with user identity |
| Code Pattern Validation | Uppercase alphanumeric only (^[A-Z0-9_-]+$) |
| Soft Delete | No hard delete to prevent data loss |
| Campaign Code Immutability | Code cannot be modified after creation (BR-CMP-009) |
| Request Body Size | Max 10KB |
| CORS | Configured for authorized web clients |

### 12.3 Audit Trail Security

| Security Concern | Mitigation |
|------------------|------------|
| Unauthorized modifications | JWT validation + Admin role check |
| Concurrent update conflicts | Optimistic locking with version field |
| Audit trail tampering | History records are append-only, no delete/update |
| Campaign code manipulation | Code is immutable after creation |
| User identity spoofing | User identity extracted from verified JWT claims |
| IP tracking | Client IP logged from X-Forwarded-For header |

### 12.4 Data Protection

| Data Type | Protection |
|-----------|------------|
| Campaign data | Encrypted at rest (DynamoDB) |
| Modification history | Immutable audit records, encrypted |
| User identity | Extracted from JWT claims (email/sub) |
| API requests | CloudWatch Logs (90-day retention) |
| Disable reasons | Stored with status change for compliance |

### 12.5 CloudWatch Alerting

| Alert | Severity | Notification |
|-------|----------|--------------|
| High update failure rate | Critical | SNS -> PagerDuty |
| Cache invalidation failures | High | SNS -> Slack |
| Optimistic lock conflicts spike | Medium | SNS -> Email |
| Unusual disable activity | Medium | SNS -> Slack |
| Unauthorized access attempts | High | SNS -> Security Team |

---

## 13. Signoff

| Role | Name | Date | Signature |
|------|------|------|-----------|
| Technical Lead | | | |
| Business Owner | | | |

---

## 14. TBC

| # | Item | Status |
|---|------|--------|
| TBC-001 | Campaign analytics tracking | Open |
| TBC-002 | Campaign usage tracking (redemptions) | Open |
| TBC-003 | Admin authentication and authorization | **Closed** (Cognito JWT) |
| TBC-004 | Campaign versioning for audit trail | **Closed** (version field + history) |
| TBC-005 | Bulk campaign import/export | Open |
| TBC-006 | Campaign image/banner support | Open |
| TBC-007 | Pagination for list campaigns | **Closed** (startAt pagination token) |
| TBC-008 | Campaign filtering by status | **Closed** (GSI1 status filtering) |
| TBC-009 | Campaign scheduling (auto-activate/expire) | **Closed** (SCHEDULED status) |
| TBC-010 | Multi-product campaigns | Open |
| TBC-011 | Cart service integration for grace period | Open |
| TBC-012 | S3 archival pipeline for old history records | Open |
| TBC-013 | CloudFront distribution ID parameterization | Open |
| TBC-014 | Notification on disable (email to campaign owner) | Open |

---

## 15. Definition of Terms

| Term | Definition |
|------|------------|
| Campaign | Promotional offer with discount, date range, and conditions |
| Campaign Code | Unique identifier for a campaign (e.g., SUMMER2026) - immutable after creation |
| CRUD | Create, Read, Update, Delete - basic database operations |
| Soft Delete | Marking a record as inactive (active=false) instead of physically removing it |
| Hard Delete | Permanently removing a record from the database (not supported) |
| Active Campaign | Campaign with active=true, visible in listings |
| Valid Campaign | Active campaign within its date range (status=ACTIVE) |
| List Price | Original price before discount is applied |
| Effective Price | Calculated price after discount: listPrice * (1 - discountPercent/100) |
| Status | Campaign state: DRAFT, SCHEDULED, ACTIVE, DISABLED, EXPIRED |
| SCHEDULED | Campaign where fromDate > current date (future activation) |
| DISABLED | Campaign manually deactivated by admin (can be reactivated) |
| Optimistic Locking | Concurrency control using version numbers to prevent lost updates |
| Version Conflict | When concurrent updates conflict, detected via version mismatch (409 response) |
| Modification History | Audit trail of all changes to a campaign with timestamps and user info |
| ChangeType | Type of modification: CREATE, UPDATE, DISABLE, REACTIVATE, DELETE |
| Grace Period | 24-hour window after disable where cart discounts are still honoured |
| Cache Invalidation | Process of clearing CloudFront cached data after campaign changes |
| HATEOAS | Hypermedia As The Engine Of Application State - links in responses for navigation |
| PK | Partition Key - primary identifier in DynamoDB (CAMPAIGN#{code}) |
| SK | Sort Key - METADATA for campaign record, HISTORY#{timestamp}#{uuid} for history |
| GSI1 | Global Secondary Index for status-based queries |
| GSI2 | Global Secondary Index for date-based queries |
| Partial Update | Updating only specific fields while preserving others |
| Campaign Reactivation | Re-enabling a disabled campaign (status -> ACTIVE/SCHEDULED) |

---

## 16. Appendices

### CRUD Operations Summary

The Campaigns Lambda service implements full CRUD (Create, Read, Update, Delete) operations:

| Operation | HTTP Method | Endpoint | Status Code | Description |
|-----------|-------------|----------|-------------|-------------|
| **Create** | POST | /v1.0/campaigns | 201 Created | Create new campaign with unique code |
| **Read (List)** | GET | /v1.0/campaigns | 200 OK | List all active campaigns |
| **Read (Single)** | GET | /v1.0/campaigns/{code} | 200 OK | Get campaign by code (active only) |
| **Update** | PUT | /v1.0/campaigns/{code} | 200 OK | Update campaign (partial updates supported) |
| **Delete** | DELETE | /v1.0/campaigns/{code} | 204 No Content | Soft delete (set active=false) |

**Key Features**:
- Soft delete implementation using `active` boolean flag
- User-defined campaign codes (uppercase alphanumeric)
- Automatic status calculation based on dates
- Automatic price calculation from discount percentage
- Partial updates supported (only provided fields updated)
- Public read endpoints (no authentication)
- Admin-only write endpoints (authentication TBC)
- Comprehensive validation and error handling
- DynamoDB single-table design with PK/SK pattern

**Data Lifecycle**:
1. **Created**: Campaign created with `active=true`, auto-calculated price and status
2. **DRAFT**: Campaign scheduled for future (fromDate > now)
3. **ACTIVE**: Campaign currently valid (fromDate <= now <= toDate)
4. **EXPIRED**: Campaign ended (toDate < now)
5. **Soft Deleted**: Campaign set to `active=false`, hidden from listings but retained in DB
6. **Restored**: Soft-deleted campaign reactivated by setting `active=true`

### Project Structure

```
2_bbws_campaigns_lambda/
 src/
    handlers/
       __init__.py
       list_campaigns.py           # GET /v1.0/campaigns (public)
       get_campaign.py             # GET /v1.0/campaigns/{code} (public)
       admin_list_campaigns.py     # GET /v1.0/admin/campaigns
       create_campaign.py          # POST /v1.0/admin/campaigns
       update_campaign.py          # PUT /v1.0/admin/campaigns/{code}
       disable_campaign.py         # PATCH /v1.0/admin/campaigns/{code}/disable
       reactivate_campaign.py      # PATCH /v1.0/admin/campaigns/{code}/reactivate
       get_campaign_history.py     # GET /v1.0/admin/campaigns/{code}/history
       delete_campaign.py          # DELETE /v1.0/admin/campaigns/{code}
    services/
       __init__.py
       campaign_service.py         # Campaign business logic
       history_service.py          # Modification history service
       cache_service.py            # CloudFront cache invalidation
    repositories/
       __init__.py
       campaign_repository.py      # DynamoDB data access layer
    models/
       __init__.py
       campaign.py                 # Campaign entity model
       history.py                  # ModificationHistory model
       requests.py                 # Request models (Create, Update, Disable, Reactivate)
       responses.py                # Response models with HATEOAS
       enums.py                    # CampaignStatus, ChangeType enums
    validators/
       __init__.py
       campaign_validator.py       # Campaign field validation
       status_validator.py         # Status transition validation
       business_rule_validator.py  # BR-CMP-005 to BR-CMP-018 validation
    exceptions/
       __init__.py
       campaign_exceptions.py      # CampaignNotFoundException, ValidationException
       version_conflict.py         # VersionConflictException (409)
       status_transition.py        # InvalidStatusTransitionException
    utils/
        __init__.py
        response_builder.py         # API response formatting with HATEOAS
        hateoas_links.py            # HATEOAS link generation
        date_utils.py               # Date/status calculations
        version_utils.py            # Optimistic locking utilities
        jwt_utils.py                # JWT token parsing
        logger.py                   # CloudWatch structured logging
 tests/
    unit/
       handlers/
          test_list_campaigns.py
          test_get_campaign.py
          test_admin_list_campaigns.py
          test_create_campaign.py
          test_update_campaign.py
          test_disable_campaign.py
          test_reactivate_campaign.py
          test_get_campaign_history.py
          test_delete_campaign.py
       services/
          test_campaign_service.py
          test_history_service.py
          test_cache_service.py
       validators/
          test_status_validator.py
          test_business_rule_validator.py
       repositories/
           test_campaign_repository.py
    integration/
        test_campaign_api.py
        test_campaign_crud_flow.py
        test_campaign_disable_reactivate.py
        test_campaign_history.py
        test_optimistic_locking.py
        test_cache_invalidation.py
 terraform/
    main.tf                         # Main configuration
    api_gateway.tf                  # API Gateway with admin routes
    lambda.tf                       # All 9 Lambda functions
    dynamodb.tf                     # DynamoDB table with GSI2
    iam.tf                          # IAM roles (CloudFront invalidation)
    cloudfront.tf                   # CloudFront invalidation permissions
    cloudwatch.tf                   # Logging, metrics, alarms
    cognito.tf                      # Cognito authorizer for admin endpoints
    variables.tf                    # Input variables
    outputs.tf                      # Output values
    environments/
        dev.tfvars
        sit.tfvars
        prod.tfvars
 openapi/
    campaigns-public-api.yaml       # Public API (GET campaigns)
    campaigns-admin-api.yaml        # Admin API (CRUD + disable/reactivate)
 requirements.txt                    # Python dependencies
 requirements-dev.txt                # Development dependencies
 pytest.ini                          # Pytest configuration
 .gitignore
 README.md                           # Project documentation
```

---

## 17. References

- [Parent HLD: BBWS Customer Portal Public](../HLDs/2.1_BBWS_Customer_Portal_Public_HLD.md)
- [Product Lambda LLD (Reference)](./2.1.4_LLD_Product_Lambda.md)

---

**End of Document**
